"""Core module for using learning context for context-appropriate tutor responses"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_clinical_tutor.ipynb.

# %% auto 0
__all__ = ['logger', 'OpenRouterException', 'ClinicalTutor']

# %% ../nbs/01_clinical_tutor.ipynb 4
from typing import Dict, List, Optional, Tuple, Any, AsyncGenerator
import os
import json
import logging
import asyncio
import uuid
from datetime import datetime
from pathlib import Path
import aiohttp
from pydantic import BaseModel
from dotenv import load_dotenv
from .learning_context import LearningContext, setup_logger, LearningCategory, SmartGoal, RotationContext


# Load environment variables
load_dotenv()

logger = setup_logger(__name__)

# %% ../nbs/01_clinical_tutor.ipynb 7
class OpenRouterException(Exception):
    """Custom exception for OpenRouter API errors"""
    pass

# %% ../nbs/01_clinical_tutor.ipynb 8
class ClinicalTutor:
    """
    Clinical teaching system using LLMs for goal setting and case discussion.
    
    Features:
    - SMART goal generation
    - Case discussion
    - Progress tracking
    """
    
    def __init__(
        self,
        context_path: Optional[Path] = None,
        model: str = "anthropic/claude-3-sonnet",
        api_key: Optional[str] = None
    ):
        """
        Initialize clinical tutor.
        
        Args:
            context_path: Path for context persistence
            model: OpenRouter model identifier
            api_key: OpenRouter API key (falls back to env var)
        """
        self.api_key = api_key or os.getenv("OPENROUTER_API_KEY")
        if not self.api_key:
            raise ValueError("OpenRouter API key required")
            
        self.api_url = "https://openrouter.ai/api/v1/chat/completions"
        self.model = model
        
        self.learning_context = LearningContext(context_path)
        
        # Track current discussion
        self.current_discussion: List[Dict[str, str]] = []
    
        logger.info("Clinical tutor initialized")

    async def _get_completion(
        self,
        messages: List[Dict],
        temperature: float = 0.7,
        max_retries: int = 3
    ) -> str:
        """
        Get completion from OpenRouter API with retry logic.
        
        Args:
            messages: List of conversation messages
            temperature: Temperature for response generation
            max_retries: Maximum retry attempts
            
        Returns:
            str: Model response
            
        Raises:
            OpenRouterException: If API calls fail after retries
        """
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost:7860"
        }
        
        data = {
            "model": self.model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        for attempt in range(max_retries):
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        self.api_url,
                        headers=headers,
                        json=data,
                        timeout=30
                    ) as response:
                        response.raise_for_status()
                        result = await response.json()
                        return result["choices"][0]["message"]["content"]
                        
            except Exception as e:
                if attempt == max_retries - 1:
                    raise OpenRouterException(f"API call failed: {str(e)}")
                logger.warning(f"Retry {attempt + 1} after error: {str(e)}")
                await asyncio.sleep(1 * (attempt + 1))  # Exponential backoff
    
    async def generate_smart_goals(
        self,
        specialty: str,
        setting: str,
        num_goals: int = 3
    ) -> List[SmartGoal]:
        """
        Generate SMART goals for rotation context.
        
        Args:
            specialty: Medical specialty
            setting: Clinical setting
            num_goals: Number of goals to generate
            
        Returns:
            list: Generated SMART goals
        """
        prompt = f"""Generate {num_goals} specific learning goals for a medical trainee in {specialty} ({setting}).
    
    For each goal:
    1. Select an appropriate category from: {', '.join(cat.value for cat in LearningCategory)}
    2. Write a specific, measurable goal that builds clinical competence. Write the specific goal only for the next case discussion (i.e. it is not longitudinal across several cases). Also, this goal needs to be able to be evaluated by you - there is limited access to doctors to verify facts. 
    
    Format as JSON array with fields:
    - category: Learning category name
    - smart_version: SMART formatted goal text
    
    For example:
    [
      {{
        "category": "Clinical Reasoning",
        "smart_version": "Identify a comprehensive list of differential diagnoses for a patient with acute shortness of breath."
      }},
      {{
        "category": "Management",
        "smart_version": "Outline a detailed management plan for a patient with heart failure."
      }}
    ]
    
    Goals should be specific to the {setting} setting in {specialty}."""
    
        try:
            response = await self._get_completion([{
                "role": "system",
                "content": prompt
            }])
            
            # Parse response to extract goals
            goals_data = json.loads(response)
            
            # Convert to SmartGoal objects
            goals = []
            for data in goals_data:
                goal = SmartGoal(
                    id=f"goal_{uuid.uuid4()}",
                    category=LearningCategory(data["category"]),
                    original_input="",  # Auto-generated
                    smart_version=data["smart_version"],
                    specialty=specialty,
                    setting=setting,
                    created_at=datetime.now()
                )
                goals.append(goal)
            
            logger.info(f"Generated {len(goals)} SMART goals")
            return goals
            
        except Exception as e:
            logger.error(f"Error generating goals: {str(e)}")
            # Instead of returning empty list, generate some default goals
            default_goals = [
                SmartGoal(
                    id=f"goal_{uuid.uuid4()}",
                    category=LearningCategory.CLINICAL_REASONING,
                    original_input="",
                    smart_version=f"Develop systematic approach to common {specialty} presentations in {setting} setting",
                    specialty=specialty,
                    setting=setting,
                    created_at=datetime.now()
                ),
                SmartGoal(
                    id=f"goal_{uuid.uuid4()}",
                    category=LearningCategory.MANAGEMENT,
                    original_input="",
                    smart_version=f"Create evidence-based management plans for basic {specialty} conditions",
                    specialty=specialty,
                    setting=setting,
                    created_at=datetime.now()
                )
            ]
            return default_goals
        
    async def generate_smart_goal(
        self,
        user_input: str,
        specialty: str,
        setting: str
    ) -> Optional[SmartGoal]:
        """
        Generate SMART goal from user input.
        
        Args:
            user_input: User's goal description
            specialty: Current specialty
            setting: Current setting
            
        Returns:
            SmartGoal: Generated SMART goal
        """
        prompt = f"""Convert this learning goal into a more specific goal (Specific, Measurable, Achievable, Relevant) for a patient in {specialty} ({setting}):

"{user_input}"

1. Select the most appropriate category from: {', '.join(cat.value for cat in LearningCategory)}
2. Rewrite as a specific goal specific to {setting} in {specialty}

Format as JSON with fields:
- category: Learning category name
- smart_version: SMART formatted goal text"""

        try:
            response = await self._get_completion([{
                "role": "system",
                "content": prompt
            }])
            
            # Parse response
            data = json.loads(response)
            
            return SmartGoal(
                id=f"goal_{uuid.uuid4()}",
                category=LearningCategory(data["category"]),
                original_input=user_input,
                smart_version=data["smart_version"],
                specialty=specialty,
                setting=setting,
                created_at=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Error generating SMART goal: {str(e)}")
            return None

    async def _get_completion_stream(
            self,
            messages: List[Dict],
            temperature: float = 0.7,
            max_retries: int = 3
        ) -> AsyncGenerator[str, None]:
            """
            Get streaming completion from OpenRouter API with retry logic.
            
            Args:
                messages: Conversation messages
                temperature: Response temperature
                max_retries: Maximum retry attempts
                
            Yields:
                str: Response tokens as they arrive
            """
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json",
                "HTTP-Referer": "http://localhost:7860"
            }
            
            data = {
                "model": self.model,
                "messages": messages,
                "temperature": temperature,
                "max_tokens": 2000,
                "stream": True  # Enable streaming
            }
            
            for attempt in range(max_retries):
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.post(
                            self.api_url,
                            headers=headers,
                            json=data,
                            timeout=30
                        ) as response:
                            response.raise_for_status()
                            
                            # Process streaming response
                            async for line in response.content:
                                text = line.decode('utf-8').strip()
                                if text.startswith('data: '):
                                    try:
                                        json_str = text[6:]  # Remove 'data: ' prefix
                                        if json_str == '[DONE]':
                                            break
                                        
                                        chunk = json.loads(json_str)
                                        if token := chunk['choices'][0]['delta'].get('content'):
                                            yield token
                                            
                                    except json.JSONDecodeError:
                                        continue
                                        
                            return
                            
                except Exception as e:
                    if attempt == max_retries - 1:
                        raise OpenRouterException(f"API call failed: {str(e)}")
                    logger.warning(f"Retry {attempt + 1} after error: {str(e)}")
                    await asyncio.sleep(1 * (attempt + 1))  # Exponential backoff
    
    async def discuss_case(self, message: str) -> AsyncGenerator[str, None]:
        """
        Process case discussion message with streaming response.
        
        Args:
            message: User's message
                
        Yields:
            str: Streamed tokens of tutor's response
        """
        try:
            # Build conversation prompt
            system_prompt = self._build_discussion_prompt()
            messages = [{
                "role": "system",
                "content": system_prompt
            }, {
                "role": "user",
                "content": message
            }]
            
            # Get streaming response
            async for token in self._get_completion_stream(messages):
                yield token
                
        except Exception as e:
            logger.error(f"Error in discussion: {str(e)}")
            yield "I apologize, but I encountered an error. Please try again."
            
    def end_discussion(self) -> None:
        """End current discussion."""
        if self.learning_context.active_goal:
            self.learning_context.complete_active_goal()
            
        self.current_discussion = []
    
    def _build_discussion_prompt(self) -> str:
        """Build context-aware discussion prompt."""
        context = self.learning_context
        rotation = context.rotation
        active_goal = context.active_goal
        
        return f"""You are an experienced clinical supervisor in {rotation.specialty} 
        working in a {rotation.setting} setting. Guide the learner through case discussion
        using Socratic questioning and targeted feedback.

        Current Learning Goal:
        {active_goal.smart_version if active_goal else 'General clinical discussion'}

        Approach:
        1. Focus on clinical reasoning and decision-making
        2. Ask targeted questions to explore understanding
        3. Share relevant clinical pearls
        4. Be conversational and engaging
        5. Relate discussion to current learning goal where relevant

        Remember: The learner has strong foundational knowledge. Focus on advanced clinical concepts
        rather than basic science."""
                
    def get_discussion_history(self) -> List[Dict]:
        """
        Get current discussion history.
        
        Returns:
            list: Discussion messages
        """
        return self.current_discussion
    
    def clear_discussion() -> Tuple[List, str, Dict]:
        """Clear chat history."""
        return [], "", {
            "discussion_active": False,
            "suggested_goals": [],
            "discussion_start": None,
            "last_message": None
        }

